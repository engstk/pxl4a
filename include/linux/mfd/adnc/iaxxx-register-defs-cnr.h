/*
 * iaxxx-register-defs-cnr.h
 *
 * Copyright (c) 2018 Knowles, inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

/**********************************************************
 * This file is generated by running a format script
 * on header files shared by Firmware.
 *
 * DO NOT EDIT.
 *
 *********************************************************/
#ifndef __IAXXX_REGISTER_DEFS_CNR_H__
#define __IAXXX_REGISTER_DEFS_CNR_H__

/*** The base address for this set of registers ***/
#define IAXXX_CNR_REGS_ADDR (0x50011000)

/*** CNR_X_CLK_CTRL (0x50011000) ***/
/*
 * Control the clock from the PLL, either MPLL or APLL
 */
#define IAXXX_CNR_X_CLK_CTRL_ADDR (0x50011000)
#define IAXXX_CNR_X_CLK_CTRL_MASK_VAL 0x001ffff8
#define IAXXX_CNR_X_CLK_CTRL_RMASK_VAL 0x001ffff8
#define IAXXX_CNR_X_CLK_CTRL_WMASK_VAL 0x001ffff8
#define IAXXX_CNR_X_CLK_CTRL_RESET_VAL 0x00000000

/*
 * hpx_clk, the clock is x_clk divided by (hpx_skip_cnt + 1)
 */
#define IAXXX_CNR_X_CLK_CTRL_HPX_SKIP_CNT_MASK 0x000007f8
#define IAXXX_CNR_X_CLK_CTRL_HPX_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_X_CLK_CTRL_HPX_SKIP_CNT_POS 3
#define IAXXX_CNR_X_CLK_CTRL_HPX_SKIP_CNT_SIZE 8

/*
 * lpx_clk, the clock is x_clk divided by (lpx_skip_cnt + 1)
 */
#define IAXXX_CNR_X_CLK_CTRL_LPX_SKIP_CNT_MASK 0x0007f800
#define IAXXX_CNR_X_CLK_CTRL_LPX_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_X_CLK_CTRL_LPX_SKIP_CNT_POS 11
#define IAXXX_CNR_X_CLK_CTRL_LPX_SKIP_CNT_SIZE 8

/*
 * The rising edge of this bit causes hpx_clk and lpx_clk counter to sync
 * gracefully. To align the hpx_clk and lpx_clk edges, there are 2 steps to
 * follow. First step: write HPX_SKIP_CNT_EN(in this register) to be 1;
 * Second step: write this bit to be 1. This bit needs to have a 0->1
 * transition, which means it needs to be written to 1 from being 0.
 */
#define IAXXX_CNR_X_CLK_CTRL_DIV_CTR_SYNC_MASK 0x00080000
#define IAXXX_CNR_X_CLK_CTRL_DIV_CTR_SYNC_RESET_VAL 0x0
#define IAXXX_CNR_X_CLK_CTRL_DIV_CTR_SYNC_POS 19
#define IAXXX_CNR_X_CLK_CTRL_DIV_CTR_SYNC_SIZE 1

/*
 * Enable hpx_clk skip count divider, HPX_SKIP_CNT
 */
#define IAXXX_CNR_X_CLK_CTRL_HPX_SKIP_CNT_EN_MASK 0x00100000
#define IAXXX_CNR_X_CLK_CTRL_HPX_SKIP_CNT_EN_RESET_VAL 0x0
#define IAXXX_CNR_X_CLK_CTRL_HPX_SKIP_CNT_EN_POS 20
#define IAXXX_CNR_X_CLK_CTRL_HPX_SKIP_CNT_EN_SIZE 1

/*** CNR_UART_SAMP_CLK_CTRL (0x50011004) ***/
/*
 * UART_SAMP_CLK is an output from a N/R divider. The clock source is
 * hpx_clk. <br>To calculate the out_clk frequency: D = 2^(width of N field)
 * + N - R, out_clk = (N/D) * in_clk. If N/D is not an integer, the out_clk
 * duty cycle is not 50%
 */
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_ADDR (0x50011004)
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_MASK_VAL 0x0000ffff
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_RMASK_VAL 0x0000ffff
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_WMASK_VAL 0x0000ffff
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_RESET_VAL 0x00001e01

/*
 * NR dividers N
 */
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_N_MASK 0x0000007f
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_N_RESET_VAL 0x1
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_N_POS 0
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_N_SIZE 7

/*
 * NR dividers R
 */
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_R_MASK 0x00007f80
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_R_RESET_VAL 0x3c
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_R_POS 7
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_R_SIZE 8

/*
 * 1: UART sample clock enabled <br>0: UART sample clock disabled
 */
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_EN_MASK 0x00008000
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_EN_RESET_VAL 0x0
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_EN_POS 15
#define IAXXX_CNR_UART_SAMP_CLK_CTRL_UART_NR_CNT_EN_SIZE 1

/*** CNR_I2C_SAMP_CLK_CTRL (0x50011008) ***/
/*
 * <a href="#D4100s.CNR.PROC_CLK_CTRL.BOSS_I2C_SKIP_CNT">
 * CNR:PROC_CLK_CTRL.BOSS_I2C_SKIP_CNT </a> &gt;=MAX of (I2C0_SKIP_CNT,
 * I2C1_SKIP_CNT, I2C2_SKIP_CNT, I2C3_SKIP_CNT, I2C4_SKIP_CNT)
 */
#define IAXXX_CNR_I2C_SAMP_CLK_CTRL_ADDR (0x50011008)
#define IAXXX_CNR_I2C_SAMP_CLK_CTRL_MASK_VAL 0x0000003f
#define IAXXX_CNR_I2C_SAMP_CLK_CTRL_RMASK_VAL 0x0000003f
#define IAXXX_CNR_I2C_SAMP_CLK_CTRL_WMASK_VAL 0x0000003f
#define IAXXX_CNR_I2C_SAMP_CLK_CTRL_RESET_VAL 0x00000000

/*
 * Divide I2C clock by (i2c_skip_count + 1) for I2C
 */
#define IAXXX_CNR_I2C_SAMP_CLK_CTRL_I2C_SKIP_CNT_MASK 0x0000003f
#define IAXXX_CNR_I2C_SAMP_CLK_CTRL_I2C_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_I2C_SAMP_CLK_CTRL_I2C_SKIP_CNT_POS 0
#define IAXXX_CNR_I2C_SAMP_CLK_CTRL_I2C_SKIP_CNT_SIZE 6

/*** CNR_CLK_CGEN (0x5001100c) ***/
/*
 * Enable the clock for BOSS, SSP, HMD and GPIO INTR. The clock gate from the
 * clock root, lpx_clk, controlled by CLK_ROOT_EN must be on and their
 * respective SC count as well for the BOSS, SSP, HMD and GPIO INTR to be on
 */
#define IAXXX_CNR_CLK_CGEN_ADDR (0x5001100c)
#define IAXXX_CNR_CLK_CGEN_MASK_VAL 0x0000000f
#define IAXXX_CNR_CLK_CGEN_RMASK_VAL 0x0000000f
#define IAXXX_CNR_CLK_CGEN_WMASK_VAL 0x0000000f
#define IAXXX_CNR_CLK_CGEN_RESET_VAL 0x00000001

/*
 * enable the Skip Count clock for BOSS clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_CGEN_BOSS_LPX_CLK_CGEN_MASK 0x00000001
#define IAXXX_CNR_CLK_CGEN_BOSS_LPX_CLK_CGEN_RESET_VAL 0x1
#define IAXXX_CNR_CLK_CGEN_BOSS_LPX_CLK_CGEN_POS 0
#define IAXXX_CNR_CLK_CGEN_BOSS_LPX_CLK_CGEN_SIZE 1

/*
 * enable the Skip Count clock for SSP clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_CGEN_SSP_LPX_CLK_CGEN_MASK 0x00000002
#define IAXXX_CNR_CLK_CGEN_SSP_LPX_CLK_CGEN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_CGEN_SSP_LPX_CLK_CGEN_POS 1
#define IAXXX_CNR_CLK_CGEN_SSP_LPX_CLK_CGEN_SIZE 1

/*
 * enable the Skip Count clock for HMD clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_CGEN_HMD_LPX_CLK_CGEN_MASK 0x00000004
#define IAXXX_CNR_CLK_CGEN_HMD_LPX_CLK_CGEN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_CGEN_HMD_LPX_CLK_CGEN_POS 2
#define IAXXX_CNR_CLK_CGEN_HMD_LPX_CLK_CGEN_SIZE 1

/*
 * enable the HW control or the override to control the clock gate for GPIO
 * INTR LPX clock
 */
#define IAXXX_CNR_CLK_CGEN_GPIO_INTR_LPX_CLK_CGEN_MASK 0x00000008
#define IAXXX_CNR_CLK_CGEN_GPIO_INTR_LPX_CLK_CGEN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_CGEN_GPIO_INTR_LPX_CLK_CGEN_POS 3
#define IAXXX_CNR_CLK_CGEN_GPIO_INTR_LPX_CLK_CGEN_SIZE 1

/*** CNR_CLK_ROOT_EN (0x50011010) ***/
/*
 * Enable the clock root for various clocks
 */
#define IAXXX_CNR_CLK_ROOT_EN_ADDR (0x50011010)
#define IAXXX_CNR_CLK_ROOT_EN_MASK_VAL 0xfffffdff
#define IAXXX_CNR_CLK_ROOT_EN_RMASK_VAL 0xfffffdff
#define IAXXX_CNR_CLK_ROOT_EN_WMASK_VAL 0xfffffdff
#define IAXXX_CNR_CLK_ROOT_EN_RESET_VAL 0xa0006083

/*
 * enable the clock root for AHB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_AHB_LPX_CLK_ROOT_EN_MASK 0x00000001
#define IAXXX_CNR_CLK_ROOT_EN_AHB_LPX_CLK_ROOT_EN_RESET_VAL 0x1
#define IAXXX_CNR_CLK_ROOT_EN_AHB_LPX_CLK_ROOT_EN_POS 0
#define IAXXX_CNR_CLK_ROOT_EN_AHB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for BOSS clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_BOSS_LPX_CLK_ROOT_EN_MASK 0x00000002
#define IAXXX_CNR_CLK_ROOT_EN_BOSS_LPX_CLK_ROOT_EN_RESET_VAL 0x1
#define IAXXX_CNR_CLK_ROOT_EN_BOSS_LPX_CLK_ROOT_EN_POS 1
#define IAXXX_CNR_CLK_ROOT_EN_BOSS_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for SSP clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_SSP_LPX_CLK_ROOT_EN_MASK 0x00000004
#define IAXXX_CNR_CLK_ROOT_EN_SSP_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_SSP_LPX_CLK_ROOT_EN_POS 2
#define IAXXX_CNR_CLK_ROOT_EN_SSP_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for CM4 clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_CM4_LPX_CLK_ROOT_EN_MASK 0x00000008
#define IAXXX_CNR_CLK_ROOT_EN_CM4_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_CM4_LPX_CLK_ROOT_EN_POS 3
#define IAXXX_CNR_CLK_ROOT_EN_CM4_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for HMD clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_HMD_LPX_CLK_ROOT_EN_MASK 0x00000010
#define IAXXX_CNR_CLK_ROOT_EN_HMD_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_HMD_LPX_CLK_ROOT_EN_POS 4
#define IAXXX_CNR_CLK_ROOT_EN_HMD_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for DMX clock, register X_CLK_CTRL(0x10000000) bit
 * HXP_SKIP_CNT_EN has also to be set to enable DVT clock
 */
#define IAXXX_CNR_CLK_ROOT_EN_DMX_HPX_CLK_ROOT_EN_MASK 0x00000020
#define IAXXX_CNR_CLK_ROOT_EN_DMX_HPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_DMX_HPX_CLK_ROOT_EN_POS 5
#define IAXXX_CNR_CLK_ROOT_EN_DMX_HPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PD0 clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PD0_LPX_CLK_ROOT_EN_MASK 0x00000040
#define IAXXX_CNR_CLK_ROOT_EN_PD0_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_PD0_LPX_CLK_ROOT_EN_POS 6
#define IAXXX_CNR_CLK_ROOT_EN_PD0_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PD1 AHB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PD1_AHB_LPX_CLK_ROOT_EN_MASK 0x00000080
#define IAXXX_CNR_CLK_ROOT_EN_PD1_AHB_LPX_CLK_ROOT_EN_RESET_VAL 0x1
#define IAXXX_CNR_CLK_ROOT_EN_PD1_AHB_LPX_CLK_ROOT_EN_POS 7
#define IAXXX_CNR_CLK_ROOT_EN_PD1_AHB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PD2 AHB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PD2_AHB_LPX_CLK_ROOT_EN_MASK 0x00000100
#define IAXXX_CNR_CLK_ROOT_EN_PD2_AHB_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_PD2_AHB_LPX_CLK_ROOT_EN_POS 8
#define IAXXX_CNR_CLK_ROOT_EN_PD2_AHB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PD4 AHB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PD4_AHB_LPX_CLK_ROOT_EN_MASK 0x00000400
#define IAXXX_CNR_CLK_ROOT_EN_PD4_AHB_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_PD4_AHB_LPX_CLK_ROOT_EN_POS 10
#define IAXXX_CNR_CLK_ROOT_EN_PD4_AHB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PD5 AHB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PD5_AHB_LPX_CLK_ROOT_EN_MASK 0x00000800
#define IAXXX_CNR_CLK_ROOT_EN_PD5_AHB_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_PD5_AHB_LPX_CLK_ROOT_EN_POS 11
#define IAXXX_CNR_CLK_ROOT_EN_PD5_AHB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PD7 AHB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PD7_AHB_LPX_CLK_ROOT_EN_MASK 0x00001000
#define IAXXX_CNR_CLK_ROOT_EN_PD7_AHB_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_PD7_AHB_LPX_CLK_ROOT_EN_POS 12
#define IAXXX_CNR_CLK_ROOT_EN_PD7_AHB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PD8 AHB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PD8_AHB_LPX_CLK_ROOT_EN_MASK 0x00002000
#define IAXXX_CNR_CLK_ROOT_EN_PD8_AHB_LPX_CLK_ROOT_EN_RESET_VAL 0x1
#define IAXXX_CNR_CLK_ROOT_EN_PD8_AHB_LPX_CLK_ROOT_EN_POS 13
#define IAXXX_CNR_CLK_ROOT_EN_PD8_AHB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for CNR APB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_CNR_APB_LPX_CLK_ROOT_EN_MASK 0x00004000
#define IAXXX_CNR_CLK_ROOT_EN_CNR_APB_LPX_CLK_ROOT_EN_RESET_VAL 0x1
#define IAXXX_CNR_CLK_ROOT_EN_CNR_APB_LPX_CLK_ROOT_EN_POS 14
#define IAXXX_CNR_CLK_ROOT_EN_CNR_APB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for AO APB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_AO_APB_LPX_CLK_ROOT_EN_MASK 0x00008000
#define IAXXX_CNR_CLK_ROOT_EN_AO_APB_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_AO_APB_LPX_CLK_ROOT_EN_POS 15
#define IAXXX_CNR_CLK_ROOT_EN_AO_APB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for GPIO APB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_GPIO_APB_LPX_CLK_ROOT_EN_MASK 0x00010000
#define IAXXX_CNR_CLK_ROOT_EN_GPIO_APB_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_GPIO_APB_LPX_CLK_ROOT_EN_POS 16
#define IAXXX_CNR_CLK_ROOT_EN_GPIO_APB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PWRC APB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PWRC_APB_LPX_CLK_ROOT_EN_MASK 0x00020000
#define IAXXX_CNR_CLK_ROOT_EN_PWRC_APB_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_PWRC_APB_LPX_CLK_ROOT_EN_POS 17
#define IAXXX_CNR_CLK_ROOT_EN_PWRC_APB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for STMR APB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_STMR_APB_LPX_CLK_ROOT_EN_MASK 0x00040000
#define IAXXX_CNR_CLK_ROOT_EN_STMR_APB_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_STMR_APB_LPX_CLK_ROOT_EN_POS 18
#define IAXXX_CNR_CLK_ROOT_EN_STMR_APB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PAD_CTRL APB clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PAD_CTRL_APB_LPX_CLK_ROOT_EN_MASK 0x00080000
#define IAXXX_CNR_CLK_ROOT_EN_PAD_CTRL_APB_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_PAD_CTRL_APB_LPX_CLK_ROOT_EN_POS 19
#define IAXXX_CNR_CLK_ROOT_EN_PAD_CTRL_APB_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for PCTRL clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_PCTRL_LPX_CLK_ROOT_EN_MASK 0x00100000
#define IAXXX_CNR_CLK_ROOT_EN_PCTRL_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_PCTRL_LPX_CLK_ROOT_EN_POS 20
#define IAXXX_CNR_CLK_ROOT_EN_PCTRL_LPX_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for CM4 TMR clock, the clock root is a_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_CM4_TMR_A_CLK_ROOT_EN_MASK 0x00200000
#define IAXXX_CNR_CLK_ROOT_EN_CM4_TMR_A_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_CM4_TMR_A_CLK_ROOT_EN_POS 21
#define IAXXX_CNR_CLK_ROOT_EN_CM4_TMR_A_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for I2C sample clock SC divider, the clock root is
 * x_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_I2C_X_CLK_ROOT_EN_MASK 0x00400000
#define IAXXX_CNR_CLK_ROOT_EN_I2C_X_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_I2C_X_CLK_ROOT_EN_POS 22
#define IAXXX_CNR_CLK_ROOT_EN_I2C_X_CLK_ROOT_EN_SIZE 1

/*
 * enable x_clock root for SPI IDI clock predecoder; enable the clock root
 * for SPI sample clock IDI divider, the clock root is x_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_SPI_X_CLK_ROOT_EN_MASK 0x00800000
#define IAXXX_CNR_CLK_ROOT_EN_SPI_X_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_SPI_X_CLK_ROOT_EN_POS 23
#define IAXXX_CNR_CLK_ROOT_EN_SPI_X_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for UART sample clock NR divider, the clock root is
 * x_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_UART_X_CLK_ROOT_EN_MASK 0x01000000
#define IAXXX_CNR_CLK_ROOT_EN_UART_X_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_UART_X_CLK_ROOT_EN_POS 24
#define IAXXX_CNR_CLK_ROOT_EN_UART_X_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for AUD WALL clock, the clock root is a_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_AUD_WALL_A_CLK_ROOT_EN_MASK 0x02000000
#define IAXXX_CNR_CLK_ROOT_EN_AUD_WALL_A_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_AUD_WALL_A_CLK_ROOT_EN_POS 25
#define IAXXX_CNR_CLK_ROOT_EN_AUD_WALL_A_CLK_ROOT_EN_SIZE 1

/*
 * enable the clock root for STMR clock, the clock root is a_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_STMR_A_CLK_ROOT_EN_MASK 0x04000000
#define IAXXX_CNR_CLK_ROOT_EN_STMR_A_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_STMR_A_CLK_ROOT_EN_POS 26
#define IAXXX_CNR_CLK_ROOT_EN_STMR_A_CLK_ROOT_EN_SIZE 1

/*
 * Enable pll output clock to I2S master unit 0, the clock root is a_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_I2SM_A_CLK_ROOT_EN_MASK 0x08000000
#define IAXXX_CNR_CLK_ROOT_EN_I2SM_A_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_I2SM_A_CLK_ROOT_EN_POS 27
#define IAXXX_CNR_CLK_ROOT_EN_I2SM_A_CLK_ROOT_EN_SIZE 1

/*
 * Enable a_clk output clock to a_clk skip count, the clock root is a_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_A_CLK_ROOT_EN_MASK 0x10000000
#define IAXXX_CNR_CLK_ROOT_EN_A_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_A_CLK_ROOT_EN_POS 28
#define IAXXX_CNR_CLK_ROOT_EN_A_CLK_ROOT_EN_SIZE 1

/*
 * Enable osc_clk output clock to IDI count used to bypass CLK_IN, the clock
 * root is osc_clk. Note that reset value of this bit is 1 which means
 * oscillator clock gate will be enabled by default. This is required for
 * scenarios where INTR_API is set to 1 as defined in AO:SW_LOR:BOOT_CLK
 * register. SW is expected to clear this bit during bootup to save power.
 */
#define IAXXX_CNR_CLK_ROOT_EN_OSC_CLK_BYP_CLK_IN_ROOT_EN_MASK 0x20000000
#define IAXXX_CNR_CLK_ROOT_EN_OSC_CLK_BYP_CLK_IN_ROOT_EN_RESET_VAL 0x1
#define IAXXX_CNR_CLK_ROOT_EN_OSC_CLK_BYP_CLK_IN_ROOT_EN_POS 29
#define IAXXX_CNR_CLK_ROOT_EN_OSC_CLK_BYP_CLK_IN_ROOT_EN_SIZE 1

/*
 * Enable osc_clk output clock to IDI count used to bypass PLL, the clock
 * root is osc_clk
 */
#define IAXXX_CNR_CLK_ROOT_EN_OSC_CLK_BYP_PLL_ROOT_EN_MASK 0x40000000
#define IAXXX_CNR_CLK_ROOT_EN_OSC_CLK_BYP_PLL_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_CLK_ROOT_EN_OSC_CLK_BYP_PLL_ROOT_EN_POS 30
#define IAXXX_CNR_CLK_ROOT_EN_OSC_CLK_BYP_PLL_ROOT_EN_SIZE 1

/*
 * Turn on/off the clock gate for sys_clk_selected clock which is the result
 * of the muxing between CLK_IN and a divided version of the OSC_CLK
 */
#define IAXXX_CNR_CLK_ROOT_EN_SYS_CLK_ROOT_EN_MASK 0x80000000
#define IAXXX_CNR_CLK_ROOT_EN_SYS_CLK_ROOT_EN_RESET_VAL 0x1
#define IAXXX_CNR_CLK_ROOT_EN_SYS_CLK_ROOT_EN_POS 31
#define IAXXX_CNR_CLK_ROOT_EN_SYS_CLK_ROOT_EN_SIZE 1

/*** CNR_SPI_SAMP_CLK_CTRL (0x50011014) ***/
/*
 * SPI_SAMP_CLK is sourced from x_clk. The clocks are 50% duty cycle
 */
#define IAXXX_CNR_SPI_SAMP_CLK_CTRL_ADDR (0x50011014)
#define IAXXX_CNR_SPI_SAMP_CLK_CTRL_MASK_VAL 0x000003ff
#define IAXXX_CNR_SPI_SAMP_CLK_CTRL_RMASK_VAL 0x000003ff
#define IAXXX_CNR_SPI_SAMP_CLK_CTRL_WMASK_VAL 0x000003ff
#define IAXXX_CNR_SPI_SAMP_CLK_CTRL_RESET_VAL 0x00000000

/*
 * SPI sample clock frequency is x_clk divided by (SPI0_IDI_CNT + 1)
 */
#define IAXXX_CNR_SPI_SAMP_CLK_CTRL_SPI_IDI_CNT_MASK 0x000003ff
#define IAXXX_CNR_SPI_SAMP_CLK_CTRL_SPI_IDI_CNT_RESET_VAL 0x0
#define IAXXX_CNR_SPI_SAMP_CLK_CTRL_SPI_IDI_CNT_POS 0
#define IAXXX_CNR_SPI_SAMP_CLK_CTRL_SPI_IDI_CNT_SIZE 10

/*** CNR_PROC_CLK_CTRL (0x50011018) ***/
/*
 * Control processor clock dividers skip count value
 */
#define IAXXX_CNR_PROC_CLK_CTRL_ADDR (0x50011018)
#define IAXXX_CNR_PROC_CLK_CTRL_MASK_VAL 0x00000fff
#define IAXXX_CNR_PROC_CLK_CTRL_RMASK_VAL 0x00000fff
#define IAXXX_CNR_PROC_CLK_CTRL_WMASK_VAL 0x00000fff
#define IAXXX_CNR_PROC_CLK_CTRL_RESET_VAL 0x00000000

/*
 * An effective divide of (skip_count + 1) of the clock controlled by this
 * register for BOSS
 */
#define IAXXX_CNR_PROC_CLK_CTRL_BOSS_SKIP_CNT_MASK 0x0000000f
#define IAXXX_CNR_PROC_CLK_CTRL_BOSS_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_PROC_CLK_CTRL_BOSS_SKIP_CNT_POS 0
#define IAXXX_CNR_PROC_CLK_CTRL_BOSS_SKIP_CNT_SIZE 4

/*
 * An effective divide of (skip_count + 1) of the clock controlled by this
 * register for SSP
 */
#define IAXXX_CNR_PROC_CLK_CTRL_SSP_SKIP_CNT_MASK 0x000000f0
#define IAXXX_CNR_PROC_CLK_CTRL_SSP_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_PROC_CLK_CTRL_SSP_SKIP_CNT_POS 4
#define IAXXX_CNR_PROC_CLK_CTRL_SSP_SKIP_CNT_SIZE 4

/*
 * An effective divide of (skip_count + 1) of the clock controlled by this
 * register for HMD
 */
#define IAXXX_CNR_PROC_CLK_CTRL_HMD_SKIP_CNT_MASK 0x00000f00
#define IAXXX_CNR_PROC_CLK_CTRL_HMD_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_PROC_CLK_CTRL_HMD_SKIP_CNT_POS 8
#define IAXXX_CNR_PROC_CLK_CTRL_HMD_SKIP_CNT_SIZE 4

/*** CNR_PCTRL_CLK_CTRL (0x5001101c) ***/
/*
 * Control the clock that goes to Processor Control Module
 */
#define IAXXX_CNR_PCTRL_CLK_CTRL_ADDR (0x5001101c)
#define IAXXX_CNR_PCTRL_CLK_CTRL_MASK_VAL 0x000000ff
#define IAXXX_CNR_PCTRL_CLK_CTRL_RMASK_VAL 0x000000ff
#define IAXXX_CNR_PCTRL_CLK_CTRL_WMASK_VAL 0x000000ff
#define IAXXX_CNR_PCTRL_CLK_CTRL_RESET_VAL 0x00000000

/*
 * Divide LPX clock to (skip_count + 1) fo r processor control block
 */
#define IAXXX_CNR_PCTRL_CLK_CTRL_PCTRL_SKIP_CNT_MASK 0x000000ff
#define IAXXX_CNR_PCTRL_CLK_CTRL_PCTRL_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_PCTRL_CLK_CTRL_PCTRL_SKIP_CNT_POS 0
#define IAXXX_CNR_PCTRL_CLK_CTRL_PCTRL_SKIP_CNT_SIZE 8

/*** CNR_GPIO_INTR_CLK_CTRL (0x50011020) ***/
/*
 * Control the clock that goes to GPIO interrupt clock
 */
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_ADDR (0x50011020)
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_MASK_VAL 0x00003fff
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_RMASK_VAL 0x00003fff
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_WMASK_VAL 0x00003fff
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_RESET_VAL 0x00000000

/*
 * Divide LPX clock to (skip_count + 1) for GPIO interrupt clock
 */
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_GPIO_INTR_SKIP_CNT_MASK 0x00001fff
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_GPIO_INTR_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_GPIO_INTR_SKIP_CNT_POS 0
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_GPIO_INTR_SKIP_CNT_SIZE 13

/*
 * enable the clock root for GPIO_INTR clock, the clock root is lpx_clk
 */
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_GPIO_INTR_LPX_CLK_ROOT_EN_MASK 0x00002000
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_GPIO_INTR_LPX_CLK_ROOT_EN_RESET_VAL 0x0
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_GPIO_INTR_LPX_CLK_ROOT_EN_POS 13
#define IAXXX_CNR_GPIO_INTR_CLK_CTRL_GPIO_INTR_LPX_CLK_ROOT_EN_SIZE 1

/*** CNR_A_CLK_CTRL (0x50011024) ***/
/*
 * Controls the skip count and NR dividers for the a_clk. Note:- Once a write
 * is issued to this register you have to wait at least 3 a_clk skip counted
 * clocks before giving another write otherwise writes will be missed.
 */
#define IAXXX_CNR_A_CLK_CTRL_ADDR (0x50011024)
#define IAXXX_CNR_A_CLK_CTRL_MASK_VAL 0x000007ff
#define IAXXX_CNR_A_CLK_CTRL_RMASK_VAL 0x000007ff
#define IAXXX_CNR_A_CLK_CTRL_WMASK_VAL 0x000007ff
#define IAXXX_CNR_A_CLK_CTRL_RESET_VAL 0x00000230

/*
 * An effective divide of (skip_count + 1) of the clock controlled by this
 * register for A_CLK <br> The output of this SC divider feed a NR divider
 * (N=2, R=3).
 */
#define IAXXX_CNR_A_CLK_CTRL_A_SKIP_CNT_MASK 0x0000000f
#define IAXXX_CNR_A_CLK_CTRL_A_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_A_CLK_CTRL_A_SKIP_CNT_POS 0
#define IAXXX_CNR_A_CLK_CTRL_A_SKIP_CNT_SIZE 4

/*
 * It enables A clock skip counter. This bit has to set to be 1 for A_CLK to
 * run
 */
#define IAXXX_CNR_A_CLK_CTRL_A_SKIP_CNT_EN_MASK 0x00000010
#define IAXXX_CNR_A_CLK_CTRL_A_SKIP_CNT_EN_RESET_VAL 0x1
#define IAXXX_CNR_A_CLK_CTRL_A_SKIP_CNT_EN_POS 4
#define IAXXX_CNR_A_CLK_CTRL_A_SKIP_CNT_EN_SIZE 1

/*
 * A_NR dividers N
 */
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_N_MASK 0x00000060
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_N_RESET_VAL 0x1
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_N_POS 5
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_N_SIZE 2

/*
 * A_NR dividers R
 */
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_R_MASK 0x00000380
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_R_RESET_VAL 0x4
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_R_POS 7
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_R_SIZE 3

/*
 * It enables  a_clk_nr clock NR counter
 */
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_EN_MASK 0x00000400
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_EN_RESET_VAL 0x0
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_EN_POS 10
#define IAXXX_CNR_A_CLK_CTRL_A_NR_CNT_EN_SIZE 1

/*** CNR_CLK_EN_OVRRD (0x50011028) ***/
/*
 * These bits should be 0s under normal operation. These bits are for debug
 * or fail-safe only
 */
#define IAXXX_CNR_CLK_EN_OVRRD_ADDR (0x50011028)
#define IAXXX_CNR_CLK_EN_OVRRD_MASK_VAL 0x00001fff
#define IAXXX_CNR_CLK_EN_OVRRD_RMASK_VAL 0x00001fff
#define IAXXX_CNR_CLK_EN_OVRRD_WMASK_VAL 0x00001fff
#define IAXXX_CNR_CLK_EN_OVRRD_RESET_VAL 0x00000841

/*
 * Enables lpx_clk to drive the BOSS clock. The BOSS_CLK_DIV_EN has to be
 * set. This bit is used to override the logic that combines  with BOSS
 * PWaitiMode and Interrupt signal. When rregister JTAG_DBG bit0 is set so
 * processors are in JTAG DEBUG mode, the clock is also forced to be turned
 * on
 */
#define IAXXX_CNR_CLK_EN_OVRRD_BOSS_CLK_EN_OVRRD_MASK 0x00000001
#define IAXXX_CNR_CLK_EN_OVRRD_BOSS_CLK_EN_OVRRD_RESET_VAL 0x1
#define IAXXX_CNR_CLK_EN_OVRRD_BOSS_CLK_EN_OVRRD_POS 0
#define IAXXX_CNR_CLK_EN_OVRRD_BOSS_CLK_EN_OVRRD_SIZE 1

/*
 * Enables lpx_clk to drive the SSP clock. The SSP_CLK_DIV_EN has to be set.
 * This bit is used to override the logic that combines with SSP PWaitiMode
 * and Interrupt signal. When rregister JTAG_DBG bit0 is set so processors
 * are in JTAG DEBUG mode, the clock is also forced to be turned on
 */
#define IAXXX_CNR_CLK_EN_OVRRD_SSP_CLK_EN_OVRRD_MASK 0x00000002
#define IAXXX_CNR_CLK_EN_OVRRD_SSP_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_SSP_CLK_EN_OVRRD_POS 1
#define IAXXX_CNR_CLK_EN_OVRRD_SSP_CLK_EN_OVRRD_SIZE 1

/*
 * Enables lpx_clk to drive the CM4 clock. The CM4_CLK_DIV_EN has to be set.
 * This bit is used to override the logic that combines with CM4 PWaitiMode
 * and Interrupt signal. When rregister JTAG_DBG bit0 is set so processors
 * are in JTAG DEBUG mode, the clock is also forced to be turned on
 */
#define IAXXX_CNR_CLK_EN_OVRRD_CM4_CLK_EN_OVRRD_MASK 0x00000004
#define IAXXX_CNR_CLK_EN_OVRRD_CM4_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_CM4_CLK_EN_OVRRD_POS 2
#define IAXXX_CNR_CLK_EN_OVRRD_CM4_CLK_EN_OVRRD_SIZE 1

/*
 * Enables lpx_clk to drive the HMD clock. The HMD_CLK_DIV_EN has to be set.
 * This bit is used to override logic that combines HMD PWaitiMode and
 * Interrupt signal. When rregister JTAG_DBG bit0 is set so processors are in
 * JTAG DEBUG mode, the clock is also forced to be turned on
 */
#define IAXXX_CNR_CLK_EN_OVRRD_HMD_CLK_EN_OVRRD_MASK 0x00000008
#define IAXXX_CNR_CLK_EN_OVRRD_HMD_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_HMD_CLK_EN_OVRRD_POS 3
#define IAXXX_CNR_CLK_EN_OVRRD_HMD_CLK_EN_OVRRD_SIZE 1

/*
 * Enables hpx_clk to drive the DMX clock. This bit is used to override the
 * logic that combines DMX PWaitiMode and Interrupt signal. When rregister
 * JTAG_DBG bit0 is set so processors are in JTAG DEBUG mode, the clock is
 * also forced to be turned on
 */
#define IAXXX_CNR_CLK_EN_OVRRD_DMX_CLK_EN_OVRRD_MASK 0x00000010
#define IAXXX_CNR_CLK_EN_OVRRD_DMX_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_DMX_CLK_EN_OVRRD_POS 4
#define IAXXX_CNR_CLK_EN_OVRRD_DMX_CLK_EN_OVRRD_SIZE 1

/*
 * Override the clock gate control on PD0_LPX_CLK
 */
#define IAXXX_CNR_CLK_EN_OVRRD_PD0_CLK_EN_OVRRD_MASK 0x00000020
#define IAXXX_CNR_CLK_EN_OVRRD_PD0_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_PD0_CLK_EN_OVRRD_POS 5
#define IAXXX_CNR_CLK_EN_OVRRD_PD0_CLK_EN_OVRRD_SIZE 1

/*
 * Override the clock gate control on PD1_AHB_LPX_CLK
 */
#define IAXXX_CNR_CLK_EN_OVRRD_PD1_AHB_CLK_EN_OVRRD_MASK 0x00000040
#define IAXXX_CNR_CLK_EN_OVRRD_PD1_AHB_CLK_EN_OVRRD_RESET_VAL 0x1
#define IAXXX_CNR_CLK_EN_OVRRD_PD1_AHB_CLK_EN_OVRRD_POS 6
#define IAXXX_CNR_CLK_EN_OVRRD_PD1_AHB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the clock gate control on PD2_AHB_LPX_CLK
 */
#define IAXXX_CNR_CLK_EN_OVRRD_PD2_AHB_CLK_EN_OVRRD_MASK 0x00000080
#define IAXXX_CNR_CLK_EN_OVRRD_PD2_AHB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_PD2_AHB_CLK_EN_OVRRD_POS 7
#define IAXXX_CNR_CLK_EN_OVRRD_PD2_AHB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the clock gate control on PD4_AHB_LPX_CLK
 */
#define IAXXX_CNR_CLK_EN_OVRRD_PD4_AHB_CLK_EN_OVRRD_MASK 0x00000100
#define IAXXX_CNR_CLK_EN_OVRRD_PD4_AHB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_PD4_AHB_CLK_EN_OVRRD_POS 8
#define IAXXX_CNR_CLK_EN_OVRRD_PD4_AHB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the clock gate control on PD5_AHB_LPX_CLK
 */
#define IAXXX_CNR_CLK_EN_OVRRD_PD5_AHB_CLK_EN_OVRRD_MASK 0x00000200
#define IAXXX_CNR_CLK_EN_OVRRD_PD5_AHB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_PD5_AHB_CLK_EN_OVRRD_POS 9
#define IAXXX_CNR_CLK_EN_OVRRD_PD5_AHB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the clock gate control on PD7_AHB_LPX_CLK
 */
#define IAXXX_CNR_CLK_EN_OVRRD_PD7_AHB_CLK_EN_OVRRD_MASK 0x00000400
#define IAXXX_CNR_CLK_EN_OVRRD_PD7_AHB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_PD7_AHB_CLK_EN_OVRRD_POS 10
#define IAXXX_CNR_CLK_EN_OVRRD_PD7_AHB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the clock gate control on PD8_AHB_LPX_CLK
 */
#define IAXXX_CNR_CLK_EN_OVRRD_PD8_AHB_CLK_EN_OVRRD_MASK 0x00000800
#define IAXXX_CNR_CLK_EN_OVRRD_PD8_AHB_CLK_EN_OVRRD_RESET_VAL 0x1
#define IAXXX_CNR_CLK_EN_OVRRD_PD8_AHB_CLK_EN_OVRRD_POS 11
#define IAXXX_CNR_CLK_EN_OVRRD_PD8_AHB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the clock gate control on GPIO_INTR LPX clk. Takes effect only if
 * GPIO_INTR_LPX_CLK_CGEN is set.
 */
#define IAXXX_CNR_CLK_EN_OVRRD_GPIO_INTR_CLK_EN_OVRRD_MASK 0x00001000
#define IAXXX_CNR_CLK_EN_OVRRD_GPIO_INTR_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_EN_OVRRD_GPIO_INTR_CLK_EN_OVRRD_POS 12
#define IAXXX_CNR_CLK_EN_OVRRD_GPIO_INTR_CLK_EN_OVRRD_SIZE 1

/*** CNR_APB_CLK_OVRRD (0x5001102c) ***/
/*
 * These bits should be 0s under normal operation. These bits are for debug
 * or fail-safe only
 */
#define IAXXX_CNR_APB_CLK_OVRRD_ADDR (0x5001102c)
#define IAXXX_CNR_APB_CLK_OVRRD_MASK_VAL 0x0000003f
#define IAXXX_CNR_APB_CLK_OVRRD_RMASK_VAL 0x0000003f
#define IAXXX_CNR_APB_CLK_OVRRD_WMASK_VAL 0x0000003f
#define IAXXX_CNR_APB_CLK_OVRRD_RESET_VAL 0x00000000

/*
 * Override the PSEL signal that gates the CNR APB clock
 */
#define IAXXX_CNR_APB_CLK_OVRRD_CNR_APB_CLK_EN_OVRRD_MASK 0x00000001
#define IAXXX_CNR_APB_CLK_OVRRD_CNR_APB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_APB_CLK_OVRRD_CNR_APB_CLK_EN_OVRRD_POS 0
#define IAXXX_CNR_APB_CLK_OVRRD_CNR_APB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the PSEL signal that gates the AO APB clock
 */
#define IAXXX_CNR_APB_CLK_OVRRD_AO_APB_CLK_EN_OVRRD_MASK 0x00000002
#define IAXXX_CNR_APB_CLK_OVRRD_AO_APB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_APB_CLK_OVRRD_AO_APB_CLK_EN_OVRRD_POS 1
#define IAXXX_CNR_APB_CLK_OVRRD_AO_APB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the PSEL signal that gates the GPIO APB clock
 */
#define IAXXX_CNR_APB_CLK_OVRRD_GPIO_APB_CLK_EN_OVRRD_MASK 0x00000004
#define IAXXX_CNR_APB_CLK_OVRRD_GPIO_APB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_APB_CLK_OVRRD_GPIO_APB_CLK_EN_OVRRD_POS 2
#define IAXXX_CNR_APB_CLK_OVRRD_GPIO_APB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the PSEL signal that gates the PWR Control APB clock
 */
#define IAXXX_CNR_APB_CLK_OVRRD_PWRC_APB_CLK_EN_OVRRD_MASK 0x00000008
#define IAXXX_CNR_APB_CLK_OVRRD_PWRC_APB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_APB_CLK_OVRRD_PWRC_APB_CLK_EN_OVRRD_POS 3
#define IAXXX_CNR_APB_CLK_OVRRD_PWRC_APB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the PSEL signal that gates the STMR Control APB clock
 */
#define IAXXX_CNR_APB_CLK_OVRRD_STMR_APB_CLK_EN_OVRRD_MASK 0x00000010
#define IAXXX_CNR_APB_CLK_OVRRD_STMR_APB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_APB_CLK_OVRRD_STMR_APB_CLK_EN_OVRRD_POS 4
#define IAXXX_CNR_APB_CLK_OVRRD_STMR_APB_CLK_EN_OVRRD_SIZE 1

/*
 * Override the PSEL signal that gates the PAD_CTRL Control APB clock
 */
#define IAXXX_CNR_APB_CLK_OVRRD_PAD_CTRL_APB_CLK_EN_OVRRD_MASK 0x00000020
#define IAXXX_CNR_APB_CLK_OVRRD_PAD_CTRL_APB_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_APB_CLK_OVRRD_PAD_CTRL_APB_CLK_EN_OVRRD_POS 5
#define IAXXX_CNR_APB_CLK_OVRRD_PAD_CTRL_APB_CLK_EN_OVRRD_SIZE 1

/*** CNR_PD_GLOBAL_CLK_EN_OVRRD (0x50011030) ***/
/*
 * These bits should be 0s under normal operation. These bits are for debug
 * or fail-safe only
 */
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_ADDR (0x50011030)
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_MASK_VAL 0x0000001f
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_RMASK_VAL 0x0000001f
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_WMASK_VAL 0x0000001f
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_RESET_VAL 0x00000000

/*
 * Enables the clock gates for
 * pd1_reg_apb_ahb_lpx_clk,pd1_dbg_apb_ahb_lpx_clk and pd1_gated_ahb_lpx_clk.
 */
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD1_GLOBAL_CLK_EN_OVRRD_MASK 0x00000001
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD1_GLOBAL_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD1_GLOBAL_CLK_EN_OVRRD_POS 0
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD1_GLOBAL_CLK_EN_OVRRD_SIZE 1

/*
 * Enables the clock gates for
 * pd2_reg_apb_ahb_lpx_clk,pd2_dbg_apb_ahb_lpx_clk and pd2_gated_ahb_lpx_clk.
 */
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD2_GLOBAL_CLK_EN_OVRRD_MASK 0x00000002
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD2_GLOBAL_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD2_GLOBAL_CLK_EN_OVRRD_POS 1
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD2_GLOBAL_CLK_EN_OVRRD_SIZE 1

/*
 * Enables the clock gates for
 * pd3_reg_apb_ahb_lpx_clk,pd3_dbg_apb_ahb_lpx_clk and pd3_gated_ahb_lpx_clk.
 */
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD3_GLOBAL_CLK_EN_OVRRD_MASK 0x00000004
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD3_GLOBAL_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD3_GLOBAL_CLK_EN_OVRRD_POS 2
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD3_GLOBAL_CLK_EN_OVRRD_SIZE 1

/*
 * Enables the clock gates for
 * pd4_reg_apb_ahb_lpx_clk,pd4_dbg_apb_ahb_lpx_clk and pd4_gated_ahb_lpx_clk.
 */
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD4_GLOBAL_CLK_EN_OVRRD_MASK 0x00000008
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD4_GLOBAL_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD4_GLOBAL_CLK_EN_OVRRD_POS 3
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD4_GLOBAL_CLK_EN_OVRRD_SIZE 1

/*
 * Enables the clock gates for
 * pd5_reg_apb_ahb_lpx_clk,pd5_dbg_apb_ahb_lpx_clk and pd5_gated_ahb_lpx_clk.
 */
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD5_GLOBAL_CLK_EN_OVRRD_MASK 0x00000010
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD5_GLOBAL_CLK_EN_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD5_GLOBAL_CLK_EN_OVRRD_POS 4
#define IAXXX_CNR_PD_GLOBAL_CLK_EN_OVRRD_PD5_GLOBAL_CLK_EN_OVRRD_SIZE 1

/*** CNR_PWR_DOMAIN_SOFT_RST (0x50011034) ***/
/*
 * Power domain reset. The reset for PD1, where BOSS resides, is not in this
 * register. PD1 reset is logic control
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_ADDR (0x50011034)
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_MASK_VAL 0x000001bf
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_RMASK_VAL 0x000001bf
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_WMASK_VAL 0x000001bf
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_RESET_VAL 0x000001bd

/*
 * Power Domain 0 soft reset
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD0_SOFT_RST_MASK 0x00000001
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD0_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD0_SOFT_RST_POS 0
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD0_SOFT_RST_SIZE 1

/*
 * Power Domain 1 soft reset. It is BOSS power domain reset when it is
 * controlled by software.Note that this also resets APB registers in PD1
 * domain. DO NOT SET THIS FOR HW CONTROLLED SLEEP/WAKEUP.
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD1_SOFT_RST_MASK 0x00000002
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD1_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD1_SOFT_RST_POS 1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD1_SOFT_RST_SIZE 1

/*
 * Power Domain 2 soft reset. It is the SSP processor and its peripheral
 * reset
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD2_SOFT_RST_MASK 0x00000004
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD2_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD2_SOFT_RST_POS 2
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD2_SOFT_RST_SIZE 1

/*
 * Power Domain 3 soft reset. It is the the CM4 processor reset. DO NOT SET
 * THIS FOR HW CONTROLLED SLEEP/WAKEUP
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD3_SOFT_RST_MASK 0x00000008
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD3_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD3_SOFT_RST_POS 3
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD3_SOFT_RST_SIZE 1

/*
 * Power Domain 4 soft reset. It is the HMD processor and its peripheral
 * reset
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD4_SOFT_RST_MASK 0x00000010
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD4_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD4_SOFT_RST_POS 4
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD4_SOFT_RST_SIZE 1

/*
 * Power Domain 5 soft reset. It is the DMX processor  and its peripheral
 * reset
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD5_SOFT_RST_MASK 0x00000020
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD5_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD5_SOFT_RST_POS 5
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD5_SOFT_RST_SIZE 1

/*
 * Power Domain 7 soft reset. It is the PD7 reset
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD7_SOFT_RST_MASK 0x00000080
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD7_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD7_SOFT_RST_POS 7
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD7_SOFT_RST_SIZE 1

/*
 * Power-On-Reset to CM4. Can be toggled independently from CM4 processor
 * core reset, so peripherals may be left running for core reset.
 */
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD3_POR_SOFT_RST_MASK 0x00000100
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD3_POR_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD3_POR_SOFT_RST_POS 8
#define IAXXX_CNR_PWR_DOMAIN_SOFT_RST_PD3_POR_SOFT_RST_SIZE 1

/*** CNR_FUNC_SOFT_RST (0x50011038) ***/
/*
 * Reset the corresponding module, by default the modules,CCAL and STMR, are
 * kept in reset
 */
#define IAXXX_CNR_FUNC_SOFT_RST_ADDR (0x50011038)
#define IAXXX_CNR_FUNC_SOFT_RST_MASK_VAL 0x00000003
#define IAXXX_CNR_FUNC_SOFT_RST_RMASK_VAL 0x00000003
#define IAXXX_CNR_FUNC_SOFT_RST_WMASK_VAL 0x00000003
#define IAXXX_CNR_FUNC_SOFT_RST_RESET_VAL 0x00000003

/*
 * Clock Calibration reset in CNR. Before write 1 to this bit, set
 * CNR.CAL_CLK_SRC_SEL1 = 0xD and CNR.CAL_CLK_SRC_SEL2 = 0xD
 */
#define IAXXX_CNR_FUNC_SOFT_RST_CCAL_SOFT_RST_MASK 0x00000001
#define IAXXX_CNR_FUNC_SOFT_RST_CCAL_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_FUNC_SOFT_RST_CCAL_SOFT_RST_POS 0
#define IAXXX_CNR_FUNC_SOFT_RST_CCAL_SOFT_RST_SIZE 1

/*
 * Sensor timer reset.
 */
#define IAXXX_CNR_FUNC_SOFT_RST_STMR_SOFT_RST_MASK 0x00000002
#define IAXXX_CNR_FUNC_SOFT_RST_STMR_SOFT_RST_RESET_VAL 0x1
#define IAXXX_CNR_FUNC_SOFT_RST_STMR_SOFT_RST_POS 1
#define IAXXX_CNR_FUNC_SOFT_RST_STMR_SOFT_RST_SIZE 1

/*** CNR_APB_REG_SOFT_RST (0x5001103c) ***/
/*
 * Reset for AO module APB registers and PD APB registers
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_ADDR (0x5001103c)
#define IAXXX_CNR_APB_REG_SOFT_RST_MASK_VAL 0x00003ffe
#define IAXXX_CNR_APB_REG_SOFT_RST_RMASK_VAL 0x00003ffe
#define IAXXX_CNR_APB_REG_SOFT_RST_WMASK_VAL 0x00000000
#define IAXXX_CNR_APB_REG_SOFT_RST_RESET_VAL 0x00000000

/*
 * Write 1 to reset AO APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_AO_APB_REG_SOFT_RST_MASK 0x00000002
#define IAXXX_CNR_APB_REG_SOFT_RST_AO_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_AO_APB_REG_SOFT_RST_POS 1
#define IAXXX_CNR_APB_REG_SOFT_RST_AO_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset GPIO APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_GPIO_APB_REG_SOFT_RST_MASK 0x00000004
#define IAXXX_CNR_APB_REG_SOFT_RST_GPIO_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_GPIO_APB_REG_SOFT_RST_POS 2
#define IAXXX_CNR_APB_REG_SOFT_RST_GPIO_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset all PD0 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR0_APB_REG_SOFT_RST_MASK 0x00000008
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR0_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR0_APB_REG_SOFT_RST_POS 3
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR0_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset all PD7 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR7_APB_REG_SOFT_RST_MASK 0x00000010
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR7_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR7_APB_REG_SOFT_RST_POS 4
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR7_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset all PD8 APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR8_APB_REG_SOFT_RST_MASK 0x00000020
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR8_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR8_APB_REG_SOFT_RST_POS 5
#define IAXXX_CNR_APB_REG_SOFT_RST_CNR8_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset PWRC APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_PWRC_APB_REG_SOFT_RST_MASK 0x00000040
#define IAXXX_CNR_APB_REG_SOFT_RST_PWRC_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_PWRC_APB_REG_SOFT_RST_POS 6
#define IAXXX_CNR_APB_REG_SOFT_RST_PWRC_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset STMR APB registers only. It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_STMR_APB_REG_SOFT_RST_MASK 0x00000080
#define IAXXX_CNR_APB_REG_SOFT_RST_STMR_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_STMR_APB_REG_SOFT_RST_POS 7
#define IAXXX_CNR_APB_REG_SOFT_RST_STMR_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset PAD_CTRL APB registers only. It will always read back as
 * 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_PAD_CTRL_APB_REG_SOFT_RST_MASK 0x00000100
#define IAXXX_CNR_APB_REG_SOFT_RST_PAD_CTRL_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_PAD_CTRL_APB_REG_SOFT_RST_POS 8
#define IAXXX_CNR_APB_REG_SOFT_RST_PAD_CTRL_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset all PD1 APB registers except BOSS debug. BOSS debug is
 * reset by  AO:OCD.BOSS_DRESET.  It will always read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_BOSS_APB_REG_SOFT_RST_MASK 0x00000200
#define IAXXX_CNR_APB_REG_SOFT_RST_BOSS_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_BOSS_APB_REG_SOFT_RST_POS 9
#define IAXXX_CNR_APB_REG_SOFT_RST_BOSS_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset all PD2 APB registers except SSP debug. SSP debug is
 * reset by  <a href="#D4100s.AO.OCD">AO:OCD.SSP_DRESET</a> It will always
 * read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_SSP_APB_REG_SOFT_RST_MASK 0x00000400
#define IAXXX_CNR_APB_REG_SOFT_RST_SSP_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_SSP_APB_REG_SOFT_RST_POS 10
#define IAXXX_CNR_APB_REG_SOFT_RST_SSP_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset all PD3 APB registers except CM4 debug. CM4 debug is
 * reset by  <a href="#D4100s.AO.OCD">AO:OCD.CM4_DRESET</a>It will always
 * read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_CM4_APB_REG_SOFT_RST_MASK 0x00000800
#define IAXXX_CNR_APB_REG_SOFT_RST_CM4_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_CM4_APB_REG_SOFT_RST_POS 11
#define IAXXX_CNR_APB_REG_SOFT_RST_CM4_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset all PD4 APB registers except HMD debug. HMD debug is
 * reset by  <a href="#D4100s.AO.OCD">AO:OCD.HMD_DRESET</a> It will always
 * read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_HMD_APB_REG_SOFT_RST_MASK 0x00001000
#define IAXXX_CNR_APB_REG_SOFT_RST_HMD_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_HMD_APB_REG_SOFT_RST_POS 12
#define IAXXX_CNR_APB_REG_SOFT_RST_HMD_APB_REG_SOFT_RST_SIZE 1

/*
 * Write 1 to reset all PD5 APB registers except DMX debug. DMX debug is
 * reset by  <a href="#D4100s.AO.OCD">AO:OCD.DMX_DRESET</a> It will always
 * read back as 0
 */
#define IAXXX_CNR_APB_REG_SOFT_RST_DMX_APB_REG_SOFT_RST_MASK 0x00002000
#define IAXXX_CNR_APB_REG_SOFT_RST_DMX_APB_REG_SOFT_RST_RESET_VAL 0x0
#define IAXXX_CNR_APB_REG_SOFT_RST_DMX_APB_REG_SOFT_RST_POS 13
#define IAXXX_CNR_APB_REG_SOFT_RST_DMX_APB_REG_SOFT_RST_SIZE 1

/*** CNR_CLK_SRC_SEL (0x50011040) ***/
/*
 * Select clock source to/from PLL, SYS_CLK
 */
#define IAXXX_CNR_CLK_SRC_SEL_ADDR (0x50011040)
#define IAXXX_CNR_CLK_SRC_SEL_MASK_VAL 0x00ffffff
#define IAXXX_CNR_CLK_SRC_SEL_RMASK_VAL 0x00ffffff
#define IAXXX_CNR_CLK_SRC_SEL_WMASK_VAL 0x00ffffff
#define IAXXX_CNR_CLK_SRC_SEL_RESET_VAL 0x00009900

/*
 * "Select clock source for main PLL. <br>0000: SYS_CLK, this clock is also
 * used for SCTRL module. It can be either divided OSC clock or CLK_in,
 * depending on LOR setting; <br>0001: PORTA_CLK; <br>0010: PORTB_CLK;
 * <br>0011: PORTC_CLK; <br>0100: PORTD_CLK; <br>0101: PORTE_CLK; <br>0110:
 * PORTF_CLK; <br>0111: MIPI_CLK; <br>1000: SBUS_REF_CLK; <br>1001:
 * OSC_CLK_DIVD; <br>1010: CDC_MCLK; <br>1011: CLK_IN
 */
#define IAXXX_CNR_CLK_SRC_SEL_MPLL_SRC_SEL_MASK 0x0000000f
#define IAXXX_CNR_CLK_SRC_SEL_MPLL_SRC_SEL_RESET_VAL 0x0
#define IAXXX_CNR_CLK_SRC_SEL_MPLL_SRC_SEL_POS 0
#define IAXXX_CNR_CLK_SRC_SEL_MPLL_SRC_SEL_SIZE 4

/*
 * "Select clock source for audio PLL.<br>0000: SYS_CLK, this clock is also
 * used for SCTRL module. It can be either divided OSC clock or CLK_in,
 * depending on LOR setting; <br>0001: PORTA_CLK; <br>0010: PORTB_CLK;
 * <br>0011: PORTC_CLK; <br>0100: PORTD_CLK; <br>0101: PORTE_CLK; <br>0110:
 * PORTF_CLK; <br>0111: MIPI_CLK; <br>1000: SBUS_REF_CLK; <br>1001:
 * OSC_CLK_DIVD; <br>1010: CDC_MCLK; <br>1011: CLK_IN
 */
#define IAXXX_CNR_CLK_SRC_SEL_APLL_SRC_SEL_MASK 0x000000f0
#define IAXXX_CNR_CLK_SRC_SEL_APLL_SRC_SEL_RESET_VAL 0x0
#define IAXXX_CNR_CLK_SRC_SEL_APLL_SRC_SEL_POS 4
#define IAXXX_CNR_CLK_SRC_SEL_APLL_SRC_SEL_SIZE 4

/*
 * "0000: SYS_CLK, this clock is also used for SCTRL module. It can be either
 * divided OSC clock or CLK_in, depending on LOR setting; <br>0001:
 * PORTA_CLK; <br>0010: PORTB_CLK; <br>0011: PORTC_CLK; <br>0100: PORTD_CLK;
 * <br>0101: PORTE_CLK; <br>0110: PORTF_CLK; <br>0111: MIPI_CLK; <br>1000:
 * SBUS_REF_CLK; <br>1001: OSC_CLK_DIVD; <br>1010: CAL_REF_CLK; <br>1011:
 * CDC_MCLK; <br>1100: CLK_IN; <br>1101, 1110, 1111: no clock is selected.
 * The output of the mux is 0
 */
#define IAXXX_CNR_CLK_SRC_SEL_CAL_CLK_SRC_SEL1_MASK 0x00000f00
#define IAXXX_CNR_CLK_SRC_SEL_CAL_CLK_SRC_SEL1_RESET_VAL 0x9
#define IAXXX_CNR_CLK_SRC_SEL_CAL_CLK_SRC_SEL1_POS 8
#define IAXXX_CNR_CLK_SRC_SEL_CAL_CLK_SRC_SEL1_SIZE 4

/*
 * "0000: SYS_CLK, this clock is also used for SCTRL module. It can be either
 * divided OSC clock or CLK_in, depending on LOR setting; <br>0001:
 * PORTA_CLK; <br>0010: PORTB_CLK; <br>0011: PORTC_CLK; <br>0100: PORTD_CLK;
 * <br>0101: PORTE_CLK; <br>0110: PORTF_CLK; <br>0111: MIPI_CLK; <br>1000:
 * SBUS_REF_CLK; <br>1001: OSC_CLK_DIVD; <br>1010: CAL_REF_CLK; <br>1011:
 * CDC_MCLK; <br>1100: CLK_IN; <br>1101, 1110, 1111: no clock is selected.
 * The output of the mux is 0
 */
#define IAXXX_CNR_CLK_SRC_SEL_CAL_CLK_SRC_SEL2_MASK 0x0000f000
#define IAXXX_CNR_CLK_SRC_SEL_CAL_CLK_SRC_SEL2_RESET_VAL 0x9
#define IAXXX_CNR_CLK_SRC_SEL_CAL_CLK_SRC_SEL2_POS 12
#define IAXXX_CNR_CLK_SRC_SEL_CAL_CLK_SRC_SEL2_SIZE 4

/*
 * 1: MPLL bypassed; the input to the PLL is used directly for CNR clock
 * root; 0: MPLL is not bypassed
 */
#define IAXXX_CNR_CLK_SRC_SEL_MPLL_BYPASS_MASK 0x00010000
#define IAXXX_CNR_CLK_SRC_SEL_MPLL_BYPASS_RESET_VAL 0x0
#define IAXXX_CNR_CLK_SRC_SEL_MPLL_BYPASS_POS 16
#define IAXXX_CNR_CLK_SRC_SEL_MPLL_BYPASS_SIZE 1

/*
 * 1: APLL bypassed; the input to the APLL is used directly for CNR clock
 * root; 0: APLL is not bypassed
 */
#define IAXXX_CNR_CLK_SRC_SEL_APLL_BYPASS_MASK 0x00020000
#define IAXXX_CNR_CLK_SRC_SEL_APLL_BYPASS_RESET_VAL 0x0
#define IAXXX_CNR_CLK_SRC_SEL_APLL_BYPASS_POS 17
#define IAXXX_CNR_CLK_SRC_SEL_APLL_BYPASS_SIZE 1

/*
 * 00 | 11: XCLK is from MPLL; <br>01: XCLK is from APLL; <br>10: XCLK is
 * from OSC; <br>The switch between the MPLL, APLL and OSC is a glitchless
 * switch
 */
#define IAXXX_CNR_CLK_SRC_SEL_X_ROOT_SEL_MASK 0x000c0000
#define IAXXX_CNR_CLK_SRC_SEL_X_ROOT_SEL_RESET_VAL 0x0
#define IAXXX_CNR_CLK_SRC_SEL_X_ROOT_SEL_POS 18
#define IAXXX_CNR_CLK_SRC_SEL_X_ROOT_SEL_SIZE 2

/*
 * 00 | 11: XCLK is from APLL; <br>01: XCLK is from MPLL; <br>10: XCLK is
 * from OSC; <br>The switch between the MPLL, APLL and OSC is a glitchless
 * switch
 */
#define IAXXX_CNR_CLK_SRC_SEL_A_ROOT_SEL_MASK 0x00300000
#define IAXXX_CNR_CLK_SRC_SEL_A_ROOT_SEL_RESET_VAL 0x0
#define IAXXX_CNR_CLK_SRC_SEL_A_ROOT_SEL_POS 20
#define IAXXX_CNR_CLK_SRC_SEL_A_ROOT_SEL_SIZE 2

/*
 * "0: LOR determines which of the CLK_IN or divided OSC clock is used for
 * SCTRL clock for boot up. <br>1: When it is set to be 1 ""SYS_CLK_SRC_SEL""
 * in this register determines which of the CLK_IN or divided OSC clock is
 * used for SCTRL clock for boot up."
 */
#define IAXXX_CNR_CLK_SRC_SEL_LOR_OVRRD_MASK 0x00400000
#define IAXXX_CNR_CLK_SRC_SEL_LOR_OVRRD_RESET_VAL 0x0
#define IAXXX_CNR_CLK_SRC_SEL_LOR_OVRRD_POS 22
#define IAXXX_CNR_CLK_SRC_SEL_LOR_OVRRD_SIZE 1

/*
 * This bit only takes effect when LOR_OVRRD is set to 1.Selected clock goes
 * to SCTRL for booting.
 * 0: Select divided down OSC clock as sys_clk.
 * 1: Select CLK_IN from PAD as sys_clk.
 */
#define IAXXX_CNR_CLK_SRC_SEL_SYS_CLK_SRC_SEL_MASK 0x00800000
#define IAXXX_CNR_CLK_SRC_SEL_SYS_CLK_SRC_SEL_RESET_VAL 0x0
#define IAXXX_CNR_CLK_SRC_SEL_SYS_CLK_SRC_SEL_POS 23
#define IAXXX_CNR_CLK_SRC_SEL_SYS_CLK_SRC_SEL_SIZE 1

/*** CNR_OSC_CLK_CTRL (0x50011044) ***/
/*
 * Controls the OSC clock divider
 */
#define IAXXX_CNR_OSC_CLK_CTRL_ADDR (0x50011044)
#define IAXXX_CNR_OSC_CLK_CTRL_MASK_VAL 0x00000fff
#define IAXXX_CNR_OSC_CLK_CTRL_RMASK_VAL 0x00000fff
#define IAXXX_CNR_OSC_CLK_CTRL_WMASK_VAL 0x00000fff
#define IAXXX_CNR_OSC_CLK_CTRL_RESET_VAL 0x00000862

/*
 * Divides OSC clock by (OSC_BYP_CLK_IN_IDI_CNT + 1). The output of the IDI
 * is muxed with CLK_IN to provide one of the PLL reference clock
 */
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_CLK_IN_IDI_CNT_MASK 0x0000001f
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_CLK_IN_IDI_CNT_RESET_VAL 0x2
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_CLK_IN_IDI_CNT_POS 0
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_CLK_IN_IDI_CNT_SIZE 5

/*
 * Oscillator IDI divider enable signal
 */
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_CLK_IN_IDI_EN_MASK 0x00000020
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_CLK_IN_IDI_EN_RESET_VAL 0x1
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_CLK_IN_IDI_EN_POS 5
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_CLK_IN_IDI_EN_SIZE 1

/*
 * Divides OSC clock by (OSC_BYP_PLL_IDI_CNT + 1). The output of the IDI is
 * muxed with the MPLL and APLL output clocks to provide x_clk and-or a_clk
 */
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_PLL_IDI_CNT_MASK 0x000007c0
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_PLL_IDI_CNT_RESET_VAL 0x1
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_PLL_IDI_CNT_POS 6
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_PLL_IDI_CNT_SIZE 5

/*
 * Oscillator IDI divider enable signal
 */
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_PLL_IDI_EN_MASK 0x00000800
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_PLL_IDI_EN_RESET_VAL 0x1
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_PLL_IDI_EN_POS 11
#define IAXXX_CNR_OSC_CLK_CTRL_OSC_BYP_PLL_IDI_EN_SIZE 1

/*** CNR_CCAL_CTRL (0x50011048) ***/
/*
 */
#define IAXXX_CNR_CCAL_CTRL_ADDR (0x50011048)
#define IAXXX_CNR_CCAL_CTRL_MASK_VAL 0x00000077
#define IAXXX_CNR_CCAL_CTRL_RMASK_VAL 0x00000077
#define IAXXX_CNR_CCAL_CTRL_WMASK_VAL 0x00000077
#define IAXXX_CNR_CCAL_CTRL_RESET_VAL 0x00000000

/*
 * Request read from hardware counter 0. Captures snapshot of incrementing
 * counter value at the closest clock edge after this bit is asserted.  Leave
 * asserted until <a
 * href="#D4100s.CNR.CCAL_STS.RD_ACK0">CNR:CCAL_STS.RD_ACK0</a> is observed
 * equal to '1'; then software can safely read register <a
 * href="#D4100s.CNR.CCAL_CNTR0">CNR:CCAL_CNTR0</a>.
 */
#define IAXXX_CNR_CCAL_CTRL_RD_REQ0_MASK 0x00000001
#define IAXXX_CNR_CCAL_CTRL_RD_REQ0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_RD_REQ0_POS 0
#define IAXXX_CNR_CCAL_CTRL_RD_REQ0_SIZE 1

/*
 * Load value of counter 0 from <a
 * href="#D4100s.CNR.CCAL_INIT">CNR:CCAL_INIT.VAL</a>.  Leave asserted until
 * <a href="#D4100s.CNR.CCAL_STS.LOAD_ACK0">CNR:CCAL_STS.LOAD_ACK0</a> is
 * observed equal to '1'.
 */
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ0_MASK 0x00000002
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ0_POS 1
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ0_SIZE 1

/*
 * Enables counter 0 to increment.  When bit <a
 * href="#D4100s.CNR.CCAL_STS.INCR_ACK0">CNR:CCAL_STS.INCR_ACK0</a> is
 * observed equal to '1', counter has started incrementing.
 */
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ0_MASK 0x00000004
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ0_POS 2
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ0_SIZE 1

/*
 * Request read from hardware counter 1. Captures snapshot of incrementing
 * counter value at the closest clock edge after this bit is asserted.  Leave
 * asserted until <a
 * href="#D4100s.CNR.CCAL_STS.RD_ACK1">CNR:CCAL_STS.RD_ACK1</a> is observed
 * equal to '1'; then software can safely read register <a
 * href="#D4100s.CNR.CCAL_CNTR1">CNR:CCAL_CNTR1</a>.
 */
#define IAXXX_CNR_CCAL_CTRL_RD_REQ1_MASK 0x00000010
#define IAXXX_CNR_CCAL_CTRL_RD_REQ1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_RD_REQ1_POS 4
#define IAXXX_CNR_CCAL_CTRL_RD_REQ1_SIZE 1

/*
 * Load value of counter 1 from <a
 * href="#D4100s.CNR.CCAL_INIT">CNR:CCAL_INIT.VAL</a>.  Leave asserted until
 * <a href="#D4100s.CNR.CCAL_STS.LOAD_ACK1">CNR:CCAL_STS.LOAD_ACK1</a> is
 * observed equal to '1'.
 */
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ1_MASK 0x00000020
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ1_POS 5
#define IAXXX_CNR_CCAL_CTRL_LOAD_REQ1_SIZE 1

/*
 * Enables counter 1 to increment.  When bit <a
 * href="#D4100s.CNR.CCAL_STS.INCR_ACK1">CNR:CCAL_STS.INCR_ACK1</a> is
 * observed equal to '1', counter has started incrementing.
 */
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ1_MASK 0x00000040
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ1_POS 6
#define IAXXX_CNR_CCAL_CTRL_INCR_REQ1_SIZE 1

/*** CNR_CCAL_CFG (0x5001104c) ***/
/*
 */
#define IAXXX_CNR_CCAL_CFG_ADDR (0x5001104c)
#define IAXXX_CNR_CCAL_CFG_MASK_VAL 0x00000001
#define IAXXX_CNR_CCAL_CFG_RMASK_VAL 0x00000001
#define IAXXX_CNR_CCAL_CFG_WMASK_VAL 0x00000001
#define IAXXX_CNR_CCAL_CFG_RESET_VAL 0x00000000

/*
 * Synchronize control signals to Counter 1 to the clock 0 domain before
 * synchronizing them to the clock 1 domain.  This ensures that Counter 1
 * measurements start on the closest rising edge of clock 1 after clock 0;
 * this minimizes the difference between Counter 1 and Counter 0 measurement
 * windows.  Assert this bit for frequency measurements if clock 0 is 1/2 or
 * less of the frequency of clock 1.  Otherwise, leave this bit set to '0'.
 */
#define IAXXX_CNR_CCAL_CFG_SYNC_1TO0_MASK 0x00000001
#define IAXXX_CNR_CCAL_CFG_SYNC_1TO0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CFG_SYNC_1TO0_POS 0
#define IAXXX_CNR_CCAL_CFG_SYNC_1TO0_SIZE 1

/*** CNR_CCAL_STS (0x50011050) ***/
/*
 */
#define IAXXX_CNR_CCAL_STS_ADDR (0x50011050)
#define IAXXX_CNR_CCAL_STS_MASK_VAL 0x00000377
#define IAXXX_CNR_CCAL_STS_RMASK_VAL 0x00000377
#define IAXXX_CNR_CCAL_STS_WMASK_VAL 0x00000377
#define IAXXX_CNR_CCAL_STS_RESET_VAL 0x00000000

/*
 * Read acknowledge: if this bit is asserted, can safely read register <a
 * href="#D4100s.CNR.CCAL_CNTR0">CNR:CCAL_CNTR0</a>.  Then software should
 * set bit <a href="#D4100s.CNR.CCAL_CTRL.RD_REQ0">CNR:CCAL_CTRL.RD_REQ0</a>
 * back to 0, completing read request.
 */
#define IAXXX_CNR_CCAL_STS_RD_ACK0_MASK 0x00000001
#define IAXXX_CNR_CCAL_STS_RD_ACK0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_RD_ACK0_POS 0
#define IAXXX_CNR_CCAL_STS_RD_ACK0_SIZE 1

/*
 * Load acknowledged.  If asserted, can set <a
 * href="#D4100s.CNR.CCAL_CTRL.LOAD_REQ0">CNR:CCAL_CTRL.LOAD_REQ0</a> back to
 * 0.
 */
#define IAXXX_CNR_CCAL_STS_LOAD_ACK0_MASK 0x00000002
#define IAXXX_CNR_CCAL_STS_LOAD_ACK0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_LOAD_ACK0_POS 1
#define IAXXX_CNR_CCAL_STS_LOAD_ACK0_SIZE 1

/*
 * Increment acknowledged.  If asserted, can set <a
 * href="#D4100s.CNR.CCAL_CTRL.INCR_REQ0">CNR:CCAL_CTRL.INCR_REQ0</a> back to
 * 0 when desired to stop counting.
 */
#define IAXXX_CNR_CCAL_STS_INCR_ACK0_MASK 0x00000004
#define IAXXX_CNR_CCAL_STS_INCR_ACK0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_INCR_ACK0_POS 2
#define IAXXX_CNR_CCAL_STS_INCR_ACK0_SIZE 1

/*
 * Read acknowledge: if this bit is asserted, can safely read register <a
 * href="#D4100s.CNR.CCAL_CNTR1">CNR:CCAL_CNTR1</a>.  Then software should
 * set bit <a href="#D4100s.CNR.CCAL_CTRL.RD_REQ1">CNR:CCAL_CTRL.RD_REQ1</a>
 * back to 0, completing read request.
 */
#define IAXXX_CNR_CCAL_STS_RD_ACK1_MASK 0x00000010
#define IAXXX_CNR_CCAL_STS_RD_ACK1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_RD_ACK1_POS 4
#define IAXXX_CNR_CCAL_STS_RD_ACK1_SIZE 1

/*
 * Load acknowledged.  If asserted, can set <a
 * href="#D4100s.CNR.CCAL_CTRL.LOAD_REQ1">CNR:CCAL_CTRL.LOAD_REQ1</a> back to
 * 0.
 */
#define IAXXX_CNR_CCAL_STS_LOAD_ACK1_MASK 0x00000020
#define IAXXX_CNR_CCAL_STS_LOAD_ACK1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_LOAD_ACK1_POS 5
#define IAXXX_CNR_CCAL_STS_LOAD_ACK1_SIZE 1

/*
 * Increment acknowledged.  If asserted, can set <a
 * href="#D4100s.CNR.CCAL_CTRL.INCR_REQ1">CNR:CCAL_CTRL.INCR_REQ1</a> back to
 * 0 when desired to stop counting.
 */
#define IAXXX_CNR_CCAL_STS_INCR_ACK1_MASK 0x00000040
#define IAXXX_CNR_CCAL_STS_INCR_ACK1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_INCR_ACK1_POS 6
#define IAXXX_CNR_CCAL_STS_INCR_ACK1_SIZE 1

/*
 * Hardware counter 0 overflowed and restarted.  Condition is sticky: write
 * '1' to clear bit.
 */
#define IAXXX_CNR_CCAL_STS_OVRFLW0_MASK 0x00000100
#define IAXXX_CNR_CCAL_STS_OVRFLW0_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_OVRFLW0_POS 8
#define IAXXX_CNR_CCAL_STS_OVRFLW0_SIZE 1

/*
 * Hardware counter 1 overflowed and restarted.  Condition is sticky: write
 * '1' to clear bit.
 */
#define IAXXX_CNR_CCAL_STS_OVRFLW1_MASK 0x00000200
#define IAXXX_CNR_CCAL_STS_OVRFLW1_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_STS_OVRFLW1_POS 9
#define IAXXX_CNR_CCAL_STS_OVRFLW1_SIZE 1

/*** CNR_CCAL_INIT (0x50011054) ***/
/*
 */
#define IAXXX_CNR_CCAL_INIT_ADDR (0x50011054)
#define IAXXX_CNR_CCAL_INIT_MASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_INIT_RMASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_INIT_WMASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_INIT_RESET_VAL 0x00000000

/*
 * Initial value to be used to initialize either hardware counter 0 or 1.
 * Load this value into the counters 0 and 1 respectively using the bits <a
 * href="#D4100s.CNR.CCAL_CTRL.LOAD_REQ0">CNR:CCAL_CTRL.LOAD_REQ0</a> and <a
 * href="#D4100s.CNR.CCAL_CTRL.LOAD_REQ1">CNR:CCAL_CTRL.LOAD_REQ1</a>.
 */
#define IAXXX_CNR_CCAL_INIT_VAL_MASK 0x003fffff
#define IAXXX_CNR_CCAL_INIT_VAL_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_INIT_VAL_POS 0
#define IAXXX_CNR_CCAL_INIT_VAL_SIZE 22

/*** CNR_CCAL_CNTR0 (0x50011058) ***/
/*
 * During a measurement, hardware counts clock cycles on clock 0.  This
 * register reflects this buffered final count value; the counter itself may
 * be reinitialized and conduct another measurement while this value is being
 * read.    The accuracy is +/-1 reference clock cycle.
 */
#define IAXXX_CNR_CCAL_CNTR0_ADDR (0x50011058)
#define IAXXX_CNR_CCAL_CNTR0_MASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_CNTR0_RMASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_CNTR0_WMASK_VAL 0x00000000
#define IAXXX_CNR_CCAL_CNTR0_RESET_VAL 0x00000000

/*
 * Final value for counter 0 after a measurement.  Counter wraps after
 * maximium count 0X3F_FFFF.
 */
#define IAXXX_CNR_CCAL_CNTR0_VAL_MASK 0x003fffff
#define IAXXX_CNR_CCAL_CNTR0_VAL_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CNTR0_VAL_POS 0
#define IAXXX_CNR_CCAL_CNTR0_VAL_SIZE 22

/*** CNR_CCAL_CNTR1 (0x5001105c) ***/
/*
 * During a measurement, hardware counts clock cycles on clock 1.  This
 * register reflects this buffered final count value; the counter itself may
 * be reinitialized and conduct another measurement while this value is being
 * read.    The accuracy is +/-1 reference clock cycle.
 */
#define IAXXX_CNR_CCAL_CNTR1_ADDR (0x5001105c)
#define IAXXX_CNR_CCAL_CNTR1_MASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_CNTR1_RMASK_VAL 0x003fffff
#define IAXXX_CNR_CCAL_CNTR1_WMASK_VAL 0x00000000
#define IAXXX_CNR_CCAL_CNTR1_RESET_VAL 0x00000000

/*
 * Final value for counter 1 after a measurement.  Counter wraps after
 * maximium count 0X3F_FFFF.
 */
#define IAXXX_CNR_CCAL_CNTR1_VAL_MASK 0x003fffff
#define IAXXX_CNR_CCAL_CNTR1_VAL_RESET_VAL 0x0
#define IAXXX_CNR_CCAL_CNTR1_VAL_POS 0
#define IAXXX_CNR_CCAL_CNTR1_VAL_SIZE 22

/*** CNR_PROC_WAITI_STS (0x50011060) ***/
/*
 */
#define IAXXX_CNR_PROC_WAITI_STS_ADDR (0x50011060)
#define IAXXX_CNR_PROC_WAITI_STS_MASK_VAL 0x0000001f
#define IAXXX_CNR_PROC_WAITI_STS_RMASK_VAL 0x0000001f
#define IAXXX_CNR_PROC_WAITI_STS_WMASK_VAL 0x00000000
#define IAXXX_CNR_PROC_WAITI_STS_RESET_VAL 0x00000000

/*
 * if this bit is asserted, BOSS is in WAITI mode
 */
#define IAXXX_CNR_PROC_WAITI_STS_BOSS_PWAITMODE_MASK 0x00000001
#define IAXXX_CNR_PROC_WAITI_STS_BOSS_PWAITMODE_RESET_VAL 0x0
#define IAXXX_CNR_PROC_WAITI_STS_BOSS_PWAITMODE_POS 0
#define IAXXX_CNR_PROC_WAITI_STS_BOSS_PWAITMODE_SIZE 1

/*
 * if this bit is asserted, SSP is in WAITI mode
 */
#define IAXXX_CNR_PROC_WAITI_STS_SSP_PWAITMODE_MASK 0x00000002
#define IAXXX_CNR_PROC_WAITI_STS_SSP_PWAITMODE_RESET_VAL 0x0
#define IAXXX_CNR_PROC_WAITI_STS_SSP_PWAITMODE_POS 1
#define IAXXX_CNR_PROC_WAITI_STS_SSP_PWAITMODE_SIZE 1

/*
 * if this bit is asserted, CM4 is in WAITI mode
 */
#define IAXXX_CNR_PROC_WAITI_STS_CM4_PWAITMODE_MASK 0x00000004
#define IAXXX_CNR_PROC_WAITI_STS_CM4_PWAITMODE_RESET_VAL 0x0
#define IAXXX_CNR_PROC_WAITI_STS_CM4_PWAITMODE_POS 2
#define IAXXX_CNR_PROC_WAITI_STS_CM4_PWAITMODE_SIZE 1

/*
 * if this bit is asserted, HMD is in WAITI mode
 */
#define IAXXX_CNR_PROC_WAITI_STS_HMD_PWAITMODE_MASK 0x00000008
#define IAXXX_CNR_PROC_WAITI_STS_HMD_PWAITMODE_RESET_VAL 0x0
#define IAXXX_CNR_PROC_WAITI_STS_HMD_PWAITMODE_POS 3
#define IAXXX_CNR_PROC_WAITI_STS_HMD_PWAITMODE_SIZE 1

/*
 * if this bit is asserted, DMX is in WAITI mode
 */
#define IAXXX_CNR_PROC_WAITI_STS_DMX_PWAITMODE_MASK 0x00000010
#define IAXXX_CNR_PROC_WAITI_STS_DMX_PWAITMODE_RESET_VAL 0x0
#define IAXXX_CNR_PROC_WAITI_STS_DMX_PWAITMODE_POS 4
#define IAXXX_CNR_PROC_WAITI_STS_DMX_PWAITMODE_SIZE 1

/*** CNR_STMR_CLK_CTRL (0x50011064) ***/
/*
 * This register controls Sensor Interrupt Timer (STMR) clock. The clock
 * source is A_CLK_NR. <br> The clock is enabled when <a
 * href="#D4100s.CNR.A_CLK_CTRL.A_NR_CNT_EN"> CNR:A_CLK_CTRL.A_NR_CNT_EN </a>
 * <br> is enabled and <a href="#D4100s.CNR.CLK_ROOT_EN.STMR_A_CLK_ROOT_EN">
 * CNR:CLK_ROOT_EN.STMR_A_CLK_ROOT_EN </a> is enabled. <br>  The clk
 * frequency:  A_CLK_NR/(STMR_SKIP_CNT[9:0] + 1); out_clk duty cycle is not
 * 50%. Please note that STMR_A_CLK_ROOT_EN should be set to 0 before
 * updating STMR_SKIP_CNT.
 */
#define IAXXX_CNR_STMR_CLK_CTRL_ADDR (0x50011064)
#define IAXXX_CNR_STMR_CLK_CTRL_MASK_VAL 0x000007ff
#define IAXXX_CNR_STMR_CLK_CTRL_RMASK_VAL 0x000007ff
#define IAXXX_CNR_STMR_CLK_CTRL_WMASK_VAL 0x000007ff
#define IAXXX_CNR_STMR_CLK_CTRL_RESET_VAL 0x00000000

/*
 * STMR clock skip counter number
 */
#define IAXXX_CNR_STMR_CLK_CTRL_STMR_SKIP_CNT_MASK 0x000003ff
#define IAXXX_CNR_STMR_CLK_CTRL_STMR_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_STMR_CLK_CTRL_STMR_SKIP_CNT_POS 0
#define IAXXX_CNR_STMR_CLK_CTRL_STMR_SKIP_CNT_SIZE 10

/*
 * It enables STMR clock skip counter. This bit has to set to be 1 for
 * STMR_CLK to run
 */
#define IAXXX_CNR_STMR_CLK_CTRL_STMR_SKIP_CNT_EN_MASK 0x00000400
#define IAXXX_CNR_STMR_CLK_CTRL_STMR_SKIP_CNT_EN_RESET_VAL 0x0
#define IAXXX_CNR_STMR_CLK_CTRL_STMR_SKIP_CNT_EN_POS 10
#define IAXXX_CNR_STMR_CLK_CTRL_STMR_SKIP_CNT_EN_SIZE 1

/*** CNR_I2SM_CLK_CTRL (0x50011068) ***/
/*
 * I2SM clock root divider skip count value
 */
#define IAXXX_CNR_I2SM_CLK_CTRL_ADDR (0x50011068)
#define IAXXX_CNR_I2SM_CLK_CTRL_MASK_VAL 0x0000001f
#define IAXXX_CNR_I2SM_CLK_CTRL_RMASK_VAL 0x0000001f
#define IAXXX_CNR_I2SM_CLK_CTRL_WMASK_VAL 0x0000001f
#define IAXXX_CNR_I2SM_CLK_CTRL_RESET_VAL 0x00000010

/*
 * I2SM root clock skip counter number
 */
#define IAXXX_CNR_I2SM_CLK_CTRL_I2SM_SKIP_CNT_MASK 0x0000000f
#define IAXXX_CNR_I2SM_CLK_CTRL_I2SM_SKIP_CNT_RESET_VAL 0x0
#define IAXXX_CNR_I2SM_CLK_CTRL_I2SM_SKIP_CNT_POS 0
#define IAXXX_CNR_I2SM_CLK_CTRL_I2SM_SKIP_CNT_SIZE 4

/*
 * It enables I2SM clock skip counter. This bit has to set to be 1 for
 * I2SM_CLK to run
 */
#define IAXXX_CNR_I2SM_CLK_CTRL_I2SM_SKIP_CNT_EN_MASK 0x00000010
#define IAXXX_CNR_I2SM_CLK_CTRL_I2SM_SKIP_CNT_EN_RESET_VAL 0x1
#define IAXXX_CNR_I2SM_CLK_CTRL_I2SM_SKIP_CNT_EN_POS 4
#define IAXXX_CNR_I2SM_CLK_CTRL_I2SM_SKIP_CNT_EN_SIZE 1

/*** CNR_STMR_GEN_RESET (0x5001106c) ***/
/*
 * Selection and enable of STMR signals used to reset BOSS and CM4.
 */
#define IAXXX_CNR_STMR_GEN_RESET_ADDR (0x5001106c)
#define IAXXX_CNR_STMR_GEN_RESET_MASK_VAL 0x0000003f
#define IAXXX_CNR_STMR_GEN_RESET_RMASK_VAL 0x0000003f
#define IAXXX_CNR_STMR_GEN_RESET_WMASK_VAL 0x0000003f
#define IAXXX_CNR_STMR_GEN_RESET_RESET_VAL 0x00000000

/*
 * 0: Signal to reset BOSS from timer 0 is selected.
 * 1: Signal to reset BOSS from timer 1 is selected
 * 2: Signal to reset BOSS from timer 2 is selected
 * 3: Signal to reset BOSS from timer 3 is selected
 */
#define IAXXX_CNR_STMR_GEN_RESET_BOSS_SEL_MASK 0x00000003
#define IAXXX_CNR_STMR_GEN_RESET_BOSS_SEL_RESET_VAL 0x0
#define IAXXX_CNR_STMR_GEN_RESET_BOSS_SEL_POS 0
#define IAXXX_CNR_STMR_GEN_RESET_BOSS_SEL_SIZE 2

/*
 * 0/1: Signal to reset BOSS is disabled/Enabled
 */
#define IAXXX_CNR_STMR_GEN_RESET_BOSS_ENABLE_MASK 0x00000004
#define IAXXX_CNR_STMR_GEN_RESET_BOSS_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_STMR_GEN_RESET_BOSS_ENABLE_POS 2
#define IAXXX_CNR_STMR_GEN_RESET_BOSS_ENABLE_SIZE 1

/*
 * 0: Signal to reset CM4 from timer 0 is selected.
 * 1: Signal to reset CM4 from timer 1 is selected
 * 2: Signal to reset CM4 from timer 2 is selected
 * 3: Signal to reset CM4 from timer 3 is selected
 */
#define IAXXX_CNR_STMR_GEN_RESET_CM4_SEL_MASK 0x00000018
#define IAXXX_CNR_STMR_GEN_RESET_CM4_SEL_RESET_VAL 0x0
#define IAXXX_CNR_STMR_GEN_RESET_CM4_SEL_POS 3
#define IAXXX_CNR_STMR_GEN_RESET_CM4_SEL_SIZE 2

/*
 * 0/1: Signal to reset CM4 is disabled/Enabled
 */
#define IAXXX_CNR_STMR_GEN_RESET_CM4_ENABLE_MASK 0x00000020
#define IAXXX_CNR_STMR_GEN_RESET_CM4_ENABLE_RESET_VAL 0x0
#define IAXXX_CNR_STMR_GEN_RESET_CM4_ENABLE_POS 5
#define IAXXX_CNR_STMR_GEN_RESET_CM4_ENABLE_SIZE 1

/*** CNR_SPARE_GATES (0x50011070) ***/
/*
 * This is a dummy register which is tied to the spare_gates module. It does
 * not serve any functional purpose.
 */
#define IAXXX_CNR_SPARE_GATES_ADDR (0x50011070)
#define IAXXX_CNR_SPARE_GATES_MASK_VAL 0xffffffff
#define IAXXX_CNR_SPARE_GATES_RMASK_VAL 0xffffffff
#define IAXXX_CNR_SPARE_GATES_WMASK_VAL 0x0000ffff
#define IAXXX_CNR_SPARE_GATES_RESET_VAL 0x00000000

/*
 * Dummy field whose output goes in to the spare_gates module.
 */
#define IAXXX_CNR_SPARE_GATES_FIELD_1_MASK 0x0000ffff
#define IAXXX_CNR_SPARE_GATES_FIELD_1_RESET_VAL 0x0
#define IAXXX_CNR_SPARE_GATES_FIELD_1_POS 0
#define IAXXX_CNR_SPARE_GATES_FIELD_1_SIZE 16

/*
 * Dummy field which reads the output of the spare_gates module.
 */
#define IAXXX_CNR_SPARE_GATES_FIELD_2_MASK 0xffff0000
#define IAXXX_CNR_SPARE_GATES_FIELD_2_RESET_VAL 0x0
#define IAXXX_CNR_SPARE_GATES_FIELD_2_POS 16
#define IAXXX_CNR_SPARE_GATES_FIELD_2_SIZE 16

/*** CNR_EXIT_REG (0x50011fec) ***/
/*
 * Test Only
 */
#define IAXXX_CNR_EXIT_REG_ADDR (0x50011fec)
#define IAXXX_CNR_EXIT_REG_MASK_VAL 0xffffffff
#define IAXXX_CNR_EXIT_REG_RMASK_VAL 0xffffffff
#define IAXXX_CNR_EXIT_REG_WMASK_VAL 0xffffffff
#define IAXXX_CNR_EXIT_REG_RESET_VAL 0x00000000

/*
 * Reserved for hardware debug
 */
#define IAXXX_CNR_EXIT_REG_EXIT_REG_MASK 0xffffffff
#define IAXXX_CNR_EXIT_REG_EXIT_REG_RESET_VAL 0x0
#define IAXXX_CNR_EXIT_REG_EXIT_REG_POS 0
#define IAXXX_CNR_EXIT_REG_EXIT_REG_SIZE 32

/*** CNR_CNR_DUMMY (0x50011ff0) ***/
/*
 * test only
 */
#define IAXXX_CNR_CNR_DUMMY_ADDR (0x50011ff0)
#define IAXXX_CNR_CNR_DUMMY_MASK_VAL 0xffffffff
#define IAXXX_CNR_CNR_DUMMY_RMASK_VAL 0xffffffff
#define IAXXX_CNR_CNR_DUMMY_WMASK_VAL 0xffffffff
#define IAXXX_CNR_CNR_DUMMY_RESET_VAL 0x00000000

/*
 * Read/Write Dummy Registers
 */
#define IAXXX_CNR_CNR_DUMMY_CNR_DUMMY_MASK 0xffffffff
#define IAXXX_CNR_CNR_DUMMY_CNR_DUMMY_RESET_VAL 0x0
#define IAXXX_CNR_CNR_DUMMY_CNR_DUMMY_POS 0
#define IAXXX_CNR_CNR_DUMMY_CNR_DUMMY_SIZE 32

/* Number of registers in the module */
#define IAXXX_CNR_REG_NUM 31

#endif /* __IAXXX_REGISTER_DEFS_CNR_H__*/
